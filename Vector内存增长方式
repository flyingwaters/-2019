由于STL不是线程安全的, 所以在每一次插入元素,删除元素,读取元素时,必须保证原子操作.
读取元素也许要原子? 嗯,是的. 因为你得到了一个迭代器后, 这个迭代器对应的容器可能被别的线程修改!

所以(下面来自<<Effective STL>> 条款十二):
1)在每次调用容器的成员函数期间都要锁定该容器。
2)在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器。
3)在每个在容器上调用的算法执行期间锁定该容器

size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。
当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。
reserve(n)预先分配一块较大的指定大小的内存空间，其中n为分配空间大小；
resize()成员函数只改变元素的数目，不改变vector的容量。

而且由于我们的程序没有调用reserve（n）函数预先分配一块内存，所以内存增长是编译器自动完成的。
这个自动增长包括重新分配内存空间、拷贝原空间、释放原空间三个过程，具体策略为当添加元素时，
如果vector空间大小不足，则会以原大小的1.5倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。
也就是说vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，
因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间

但是，针对以上自动完成的内存增长过程，由于包括重新分配内存空间、拷贝原空间、释放原空间等步骤，这些过程会降低程序效率，
因此可以使用reserve(n)预先分配一块较大的指定大小的内存空间，
这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。
